#ゲーム
テストとか得意な人ってテスター向きなのかもね。勉強とかは特に。
今RTA見てるんだけどさ。ふとRTAってデバックなんじゃないかなーとか思ったわけでして。
そうなってくるとワイが得意なのはデバックじゃないんだろうなーって思ってさ。
なんせ俺はゲームは見るだけで十分、何なら人がしてるのを見て分析する方が得意っていうね。

#ダンス 
そらーダンスもそうなるでしょ。ダンスなんて1番それが使いやすい種目だもの。
分析がまんま活きるっていうのは非常にありがたいっていうね。

それでいうとさ、多分振り付けだけでエロくできるよなー。体の問題とかじゃなくてってことでね。
振りだけでね。

#生活 
飯の食い方もちょい変わったのよね。ちゃんとご飯が着いてくるようになったのよ。
理由は多分「飯の基本が白飯」っていう基本原理が分かったからなんだと思うけどね。
必ず主役に合うようにバランスが取られてるわけなので、主役である白飯が重要であることは確定なのよね。
じゃなきゃ一汁三菜とかなんて言われないじゃない。

このバランスの明け渡し方(というか崩し方？)が上手いほど人は「エロい」と思うんだろうなーってね。

ただ凄いとエロいはなんか違うじゃんか。その差ってなんやろな。

#Mine研究 
シクモイド関数を使うのはありかもね。1対多が大元なのでね。
0.03秒毎の差分もありか。
何となく思ったけどさ。

プラマイゼロ⇨波で表現出来るかどうかが知りたいね。
軸の言い換え⇨実体として存在する法則
骨の言い換え⇨構造物そのもの
筋肉の言い換え⇨間そのもの


時間の同期のズレか。なんかそんな気がしてきたわもはや。
人間の知覚できる限界はおそらく0.001～0.0001の間のどれかになる気がする。

0.5はエンカウントのタイミングにすぎんじゃんか。ダンサー目線は。
0.05が多分「判断」の最終調整のタイミングになるのよね。
そう考えると0.005と0.0005にも意味が生まれてくる気がする。
人間が知覚できるギリギリとかそういうことで。

何なら人間関係分子論も使えるんじゃねぇの？
⇨全体が0～4の5個じゃんか。

人間関係分子論：人間関係の構築のときって、化学の分子の構造みたいになってんじゃないの？
0層⇨意思そのもの
1層⇨自分から相手への干渉1歩目(様子見)
2層⇨自分から相手への干渉2歩目(仮定の判断)
3層⇨自分から相手への干渉3歩目(判断の最終決定)
4層⇨自分から相手への干渉4歩目(伝わってるかの確認作業)

これを上に当てはめてみるわ。この仮定さ、めっちゃミクロ＝全体合わせても多分0.3秒未満とかなのよね。

以下「層」を取った数字が左ね。
0→1がおそらく0.00005秒くらい(小数単位が重要。数字は適度に変えます。)
1→2は0.0005秒
2→3は0.005秒
3→4は0.05秒

4になった瞬間に筋肉での最終調整に入るんか。何となく予想つくわ。
んで2～3が骨だろ？さすがに1では無理だろうし。
0～1が軸。要は基盤が整うかどうかなので。

4層になったら確定だから0.5になって、まぁ1なりなんなりになりますよと。
説明できてるねぇ俺の感覚w

あとはどこで俺が音を予測なりなんなりをしてるかだけどなー。マジでわからん、自分だもの、余計ね。

予測は1～4でしょうね。0～4なら絶対心的距離になるので、0を抜いた相対距離で考えますからね。
んで全体でのプラマイゼロってのが多分予測の補正として入ってる。しかも常時。0の時も。
なので意識に来た頃には全部がプラマイゼロになってるやろなぁ。距離ごとでの0.00005フレームでの補正なんだもんね。

そう、プラマイゼロは補正の精度が0.00005なのよね。だって0の状態でも常時なんでしょ？そらぁねw

予測は外すのが人間的、ということを考えると、より現実よりなんだろうなってことになるので、1～4の中での平均的な速度で計算してみると、数字は適当に5と振ってあるので　
0.0555 / 3 = 0.0185 ≒ 0.02
くらいかな。空気読むのが0.03なので、多分それくらいの精度なんだろうね。空気読むのって基本的にクソムズじゃんか。なのでまぁ精度的に見てもこれくらいかなーってね。
空気読む＝予測か。なら1本化もできるなぁ

一応聞いてみたけどさ。やっぱり最高でも7000fps=1秒間に7000回なのよね。つまりは0.007秒が限界っぽいのよ。

なので肥大化させる必要性があるのよね、ほぼ強制的に。

手段の目的化が起こると燃え尽き症候群になりがち

中間が必要だけど中間はやめてく
⇨責任重すぎるんでね。自分には背負いきれないような畑違いの責任は背負いたくならないでしょ。
要は繋ぎ役として機能する人ね。

何となく思うのは、責任を感じたときの受け流し方が分かればこういうのも分かるんだろうなーってね。

これをどうにか図として作りたいんやけどなー。


人間関係分子論での0～4層と0.00005～0.05秒の関係と、精度が常時0.00005フレームの割り込みで機能するプラマイゼロ補正、予測が0.03と精度的に低い空気読みを全部含めたものを
conda create -n qiskit_env python=3.10 -y
conda activate qiskit_env 
pip install qiskit qiskit-aer matplotlib jupyterlab pylatexenc networkx
jupyter lab
from qiskit import QuantumCircuit, transpile
from qiskit_aer import Aer
from qiskit.visualization import plot_histogram, plot_bloch_multivector
from qiskit.quantum_info import Statevector, DensityMatrix, entropy, partial_trace
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
import matplotlib.cm as cm
###### --- 量子回路作成 ---
qc = QuantumCircuit(4, 4)
for i in range(4):
    qc.h(i)
responsibility_angles = [np.pi/6, np.pi/4, np.pi/3, np.pi/8]
for i, angle in enumerate(responsibility_angles):
    qc.ry(angle, i)
qc.cx(0, 1)
qc.cz(2, 3)
qc.cx(1, 2)
qc.cz(0, 3)
qc.measure(range(4), range(4))
###### --- 回路図表示 ---
qc.draw("mpl")
plt.title("Relationship Molecule Circuit")
plt.show()
###### --- 状態ベクトルと密度行列 ---
state = Statevector.from_instruction(qc.remove_final_measurements(inplace=False))
dm = DensityMatrix(state)
###### --- Bloch球表示 ---
plot_bloch_multivector(state)
plt.title("Bloch Sphere Representation")
plt.show()
###### --- 全体のノリエントロピー ---
vn_entropy = entropy(dm, base=2)
print(f"ノリエントロピー (von Neumann entropy): {vn_entropy:.4f}")
###### --- 依存関係ペア ---
pairs = [(0,1), (1,2), (2,3), (0,3)]
###### --- 依存関係エントロピー計算 & グラフ構築 ---
G = nx.Graph()
entropies = []
for p in pairs:
    pdm = partial_trace(dm, [i for i in range(4) if i not in p])
    ent = entropy(pdm, base=2)
    G.add_edge(p[0], p[1], weight=ent)
    entropies.append(ent)
    print(f"Qubits {p} Entanglement Entropy: {ent:.4f}")
###### --- ネットワーク図描画（色付き） ---
pos = nx.spring_layout(G)
edges = G.edges(data=True)
###### カラーマップの設定（低エントロピーは青、高は赤）
cmap = cm.get_cmap('coolwarm')
weights = []
colors = []
max_ent = max(entropies)
min_ent = min(entropies)
for _, _, edata in edges:
    w = edata['weight'] * 10  # 重みの倍率
    weights.append(w)
    # エントロピー値を0-1に正規化
    norm_val = (edata['weight'] - min_ent) / (max_ent - min_ent) if max_ent != min_ent else 0
    colors.append(cmap(norm_val))

nx.draw(G, pos, with_labels=True, width=weights, edge_color=colors, edge_cmap=cmap)
plt.title("Entanglement Network with Nori Entropy Color Gradient")
plt.show()
###### --- シミュレータ実行＆ヒストグラム表示 ---
simulator = Aer.get_backend('qasm_simulator')
compiled = transpile(qc, simulator)
result = simulator.run(compiled, shots=1024).result()
counts = result.get_counts()
plot_histogram(counts, title="Measurement Outcome Distribution")
plt.show()
に適応させたい


ゲームにおいてはRTAが同じなんだろうなってのは思うね。

限度を定めておくことが重要なんだろうな。

とりあえず今出せるのが0.001までなんで、そこまでで振るように出してみようかね。

Arduino言語を俺ができるようになった時の手順だけやっとくか。これ使えば多分色々できるようになりそうなのでね。

まずは基本仕様の確認。これでどんなもんかを見るべき。
ここは概要だけ理解しておく。概要が8割なんでね。

続いては使う目的の明確化ね。目的を決めるのはここにしてください。じゃないと手段の目的化が起こるんで。

続いて。ここまで来てようやく中身なんだけど、中身の中の概要に値するやつ(例えばライブラリとかですか)から始めてくださいね。じゃないと深堀し過ぎるんで。

ここまで来てようやく全体の俯瞰をしながらの中身になります。その都度都度で整理せんとマズいのでね。


#ダンス 
基本軸である軸骨筋肉の概念は使っておくこと。そしたら無駄に動かなくなるのでね。
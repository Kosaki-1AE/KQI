組み込みを専門に扱うものがあっても良きかもと思ったので。
土台はArduino Unoにしました。

ポートB：デジタルピン8～13
ポートC：アナログピン
ポートD：デジタルピン0～7

DDRとPORTについて
DDR：入力と出力(1/0)のどちらに使用するのか決定する
PORT：出力状態を決定する

未使用ピンは「入力ピン(プルアップ)」に設定しておく。つまり「1」です。

signed charで算術演算、unsigned charで論理演算になる

7セグの3ディジッツ：Cで桁、Dで「0」の形、Bで小数点と横線
マトリクスLED：2:6でD:C(縦軸)とD:B(横軸)

16進数とレジスタの関係性
⇨ f(15)で4ビット、7で3ビット、3で2ビット、1で1ビットが「1」になる
⇨数字一つにつき、最大で4ビットが対応可能

「^」で代入(もしくは強制割り込み)、「|」で和集合演算(∨)、「&」で積集合演算(⋀)、「>>」と「<<」でシフト

電流制限抵抗＝(電源電圧ー降下電圧) / 順方向電流

patは2進に直さないとダメ

(x, y)の場合はxが出力、yが入力になる

CTOPが上限値

「-」もしくは「~」で反転(反対の意味になるってこと)。論理演算のときは「-」、PINなど固有名詞の場合は「~」を使う。

対応ビットに格納：PINC⇨正論理に変換：~PINC & 0x30⇨右端に移動：(~PINC >> 4) & 3

「OCR2A = ++i & 1 ? 64 : 80; 」
⇨「 if( ++i & 1 ) { OCR2A = 64; } else { OCR2A = 80; }」

タイマについて
TCNT0とTCNT2：8bit＝256、TCNT1：16bit=512、プリスケーラ：128(64からの変更)
システムクロック：16MHz、Fcpu=16 * 10^6
ノーマルモードの場合：最大値に戻ってからカウンタが回る
CTCモードの場合：TOP値(つまりはOCR。これはタイマに依存する)に到達次第自動でカウンタが回る
PWMモードの場合：フルカウントの中でOCRx値でデューティ比を変化させ上限とする

OCR2A = Fcpu/PS/2 * Hz -1
Q10 = Vin / Vref * 1024
Fbuz = 1/16 * (tone * 2)
Lux = 40 * (1024/Q10 - 1)
V = r/r+10k*5

ADC：量子化値

ラの音：440Hz

ピン変化割り込み＋タイマ割り込み＝チャタリング対策
ピン変化の割り込み時のラグのところにタイマ割り込みを設定しておくとチャタリングの対策になる

UDR0：文字送信、0x0a：改行コード

rp：読み込み、wp：書き出し